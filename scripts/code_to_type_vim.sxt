<CODE>
    nvim g
</CODE>

<COMMANDS>
    # Enter arrow command mode and quit (opening vim)
    ARROW_UP 1
    EXIT_ARROW_MODE
    ENTER
</COMMANDS>

<CODE>
    # GEMM: d = alpha*a*b@b + beta*c
</CODE>

<COMMANDS>
    BACKSPACE 3
</COMMANDS>

<CODE>
    # Implement GEMM using CuPy
    import cupy as cp

    # Define matrix dimensions m, n, k
    m, n, k = 1000
</CODE>

<COMMANDS>
    BACKSPACE 2
</COMMANDS>

<CODE>
    _000_000, 40, 10

    # Create random matrices
    a = cp.random.rand(m, k, dtype=cp.float32)
    b = cp.random.rand(k, n, dtype=cp.float32)
    c = cp.random.rand(m, n, dtype=cp.float32)

    alpha = 1.5
    beta = 0.5

    # Compute GEMM
    d = alpha * a @ b + beta * c
</CODE>

<COMMANDS>
    # Sleep then navigate to new location
    SLEEP 1
    CTRL_HOME
    ARROW_DOWN 1
    ESCAPE
</COMMANDS>

<CODE>
    # Implement GEMM using nvmath-python
    import nvmath
</CODE>

<COMMANDS>
    CTRL_END
    ARROW_UP 1
    ESCAPE
</COMMANDS>

<CODE>
    d = nvmath.linalg.advanced.matmul(a, b, c, alpha=alhpa,
</CODE>

<COMMANDS>
    BACKSPACE 4
</COMMANDS>

<CODE>
    pha, beta=beta)
</CODE>

<COMMANDS>
    ARROW_UP 2
    ESCAPE
</COMMANDS>

<CODE>
    # Now benchmark with cupyx.profiler.benchmark()
</CODE>

<COMMANDS>
    CTRL_HOME
    ARROW_DOWN 5
    ESCAPE
</COMMANDS>

<CODE>
    from cupyx.profiler import benchmark
</CODE>

<COMMANDS>
    CTRL_END
    ARROW_UP 1
    ESCAPE
    ARROW_DOWN 1
</COMMANDS>

<CODE>
    benchmark(lambda: alpha * a @ b + beta * c, n_repeat=5, n_warmup=1)
    benchmark(lambda: nvmath.linalg.advanced.matmul(a, b, c, alpha=alpha, beta=beta), n_repeat=5, n_warmup=1)
</CODE>

<COMMANDS>
    ESCAPE
    ARROW_DOWN 1
</COMMANDS>

<CODE>
    print(
</CODE>

<COMMANDS>
    CTRL_END
</COMMANDS>

<CODE>
    )
</CODE>

<COMMANDS>
    ARROW_UP 1
    CTRL_HOME
</COMMANDS>

<CODE>
    print(
</CODE>

<COMMANDS>
    CTRL_END
</COMMANDS>

<CODE>
    )
</CODE>

<COMMANDS>
    ESCAPE
    SLEEP 2
</COMMANDS>
